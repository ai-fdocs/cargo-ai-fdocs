import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import chalk from "chalk";
import { NpmRegistryClient, extractGithubRepo } from "../registry.js";
import { AiDocsError } from "../error.js";

const SKIP_PATTERNS: string[] = [
  "@types/",
  "tslib",
  "typescript",
  "prettier",
  "eslint",
  "@eslint/",
  "@typescript-eslint/",
  "semver",
  "lru-cache",
  "ms",
  "debug",
];

function shouldSkip(name: string): boolean {
  return SKIP_PATTERNS.some((pattern) => (pattern.endsWith("/") ? name.startsWith(pattern) : name === pattern));
}

export async function cmdInit(projectRoot: string, overwrite: boolean): Promise<void> {
  const configPath = join(projectRoot, "ai-fdocs.toml");
  const packageJsonPath = join(projectRoot, "package.json");

  if (existsSync(configPath) && !overwrite) {
    throw new AiDocsError("ai-fdocs.toml already exists. Use --overwrite to replace.", "UNKNOWN");
  }

  if (!existsSync(packageJsonPath)) {
    throw new AiDocsError("package.json not found. Cannot init.", "FILE_NOT_FOUND");
  }

  console.log(chalk.blue("Reading package.json..."));
  const pkgJson = JSON.parse(readFileSync(packageJsonPath, "utf-8")) as {
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
  };

  const deps = {
    ...(pkgJson.dependencies ?? {}),
    ...(pkgJson.devDependencies ?? {}),
  };

  const candidates = Object.keys(deps)
    .filter((name) => !shouldSkip(name))
    .sort();
  console.log(chalk.green(`Found ${candidates.length} candidate packages.`));

  const registry = new NpmRegistryClient();
  const resolved = new Map<string, { repo: string; subpath?: string; description?: string }>();

  let skippedNoRepo = 0;
  let skippedNotGithub = 0;

  for (let i = 0; i < candidates.length; i++) {
    const name = candidates[i];
    if (i > 0 && i % 30 === 0) {
      console.log(chalk.gray(`  Progress: ${i}/${candidates.length} packages queried...`));
    }

    const info = await registry.getPackageInfo(name);
    if (!info?.repository) {
      skippedNoRepo++;
      continue;
    }

    const extracted = extractGithubRepo(info.repository);
    if (!extracted) {
      skippedNotGithub++;
      continue;
    }

    const subpath = info.subpath ?? extracted.subpath;
    resolved.set(name, { repo: extracted.repo, subpath, description: info.description ?? undefined });

    if (i % 10 === 0) await sleep(50);
  }

  console.log(chalk.green(`Resolved ${resolved.size} packages (${skippedNoRepo} no repo, ${skippedNotGithub} non-GitHub).`));

  let toml = "";
  toml += "# Generated by `ai-fdocs init`\n";
  toml += "[settings]\n";
  toml += 'output_dir = "docs/ai/vendor-docs/node"\n';
  toml += "prune = true\n";
  toml += "max_file_size_kb = 512\n";
  toml += "sync_concurrency = 8\n\n";
  toml += "# Docs source strategy for npm version (github|npm_tarball).\n";
  toml += "docs_source = \"npm_tarball\"\n\n";

  for (const [name, info] of resolved) {
    const key = needsQuoting(name) ? `"${name}"` : name;
    toml += `[packages.${key}]\n`;
    toml += `repo = "${info.repo}"\n`;
    if (info.subpath) toml += `subpath = "${info.subpath}"\n`;
    if (info.description) toml += `# ${info.description.slice(0, 100)}\n`;
    toml += "\n";
  }

  writeFileSync(configPath, toml, "utf-8");
  console.log(chalk.green(`\nâœ… Generated ai-fdocs.toml with ${resolved.size} packages.`));
}

function needsQuoting(key: string): boolean {
  return key.includes("@") || key.includes("/") || key.includes("-") || key.includes(".");
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use chrono::Utc;
use tracing::{debug, info};

use crate::config::{Config, CrateDoc};
use crate::error::{AiDocsError, Result};
use crate::fetcher::github::{FetchedFile, ResolvedRef};
use crate::processor::changelog;

const META_SCHEMA_VERSION: u32 = 1;

#[derive(serde::Serialize, serde::Deserialize, Debug)]
pub struct CrateMeta {
    #[serde(default)]
    pub schema_version: u32,
    pub version: String,
    pub git_ref: String,
    pub fetched_at: String,
    pub is_fallback: bool,
    #[serde(default)]
    pub config_fingerprint: Option<String>,
}

#[derive(Debug, Clone)]
pub struct SavedCrate {
    pub name: String,
    pub version: String,
    pub git_ref: String,
    pub is_fallback: bool,
    pub files: Vec<String>,
    pub ai_notes: String,
}

fn crate_config_fingerprint(crate_config: &CrateDoc) -> String {
    let repo = crate_config.github_repo().unwrap_or_default().trim();
    let subpath = crate_config.subpath.as_deref().unwrap_or_default().trim();

    let mut files = crate_config.effective_files().unwrap_or_default();
    files.sort();

    format!("repo={repo}\nsubpath={subpath}\nfiles={}", files.join("|"))
}

fn render_crate_summary(saved: &SavedCrate) -> String {
    let mut content = String::new();
    content.push_str(
        "<!-- This file is auto-generated by ai-fdocs. Do not edit manually. -->

",
    );

    if saved.is_fallback {
        content.push_str(&format!("# {}@{} âš ï¸\n\n", saved.name, saved.version));
        content.push_str(&format!(
            "Fetched from `{}` because no exact release tag was found for `{}`.\n\n",
            saved.git_ref, saved.version
        ));
    } else {
        content.push_str(&format!("# {}@{}\n\n", saved.name, saved.version));
    }

    if !saved.ai_notes.trim().is_empty() {
        content.push_str(&format!("## AI Notes\n\n{}\n\n", saved.ai_notes.trim()));
    }

    content.push_str("## Files\n\n");
    if saved.files.is_empty() {
        content.push_str("- _No fetched files._\n");
    } else {
        for file in &saved.files {
            content.push_str(&format!("- [{}]({})\n", file, file));
        }
    }

    content
}

pub fn flatten_filename(file_path: &str) -> String {
    if file_path.contains('/') {
        file_path.replace('/', "__")
    } else {
        file_path.to_string()
    }
}

fn inject_header(
    content: &str,
    owner_repo: &str,
    git_ref: &str,
    original_path: &str,
    is_fallback: bool,
    version: &str,
    source_url: &str,
) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    let mut header = format!(
        "<!-- AI-FDOCS: source=github.com/{owner_repo} ref={git_ref} path={original_path} fetched={date} -->\n<!-- AI-FDOCS: url={source_url} -->\n"
    );

    if is_fallback {
        header.push_str(&format!(
            "<!-- AI-FDOCS WARNING: No tag found for version {version}. Fetched from '{git_ref}' branch. Content may not match installed version. -->\n"
        ));
    }

    format!("{header}\n{content}")
}

fn should_inject_header(file_path: &str) -> bool {
    let lower = file_path.to_lowercase();
    lower.ends_with(".md") || lower.ends_with(".html") || lower.ends_with(".htm")
}

fn floor_char_boundary(s: &str, mut idx: usize) -> usize {
    idx = idx.min(s.len());
    while idx > 0 && !s.is_char_boundary(idx) {
        idx -= 1;
    }
    idx
}

fn truncate_if_needed(content: &str, max_size_kb: usize) -> String {
    let max_bytes = max_size_kb * 1024;
    if content.len() <= max_bytes {
        return content.to_string();
    }

    let boundary = floor_char_boundary(content, max_bytes);
    let truncated = &content[..boundary];
    format!("{truncated}\n\n[TRUNCATED by ai-fdocs at {max_size_kb}KB]\n")
}

fn load_meta_with_migration(meta_path: &Path) -> Option<CrateMeta> {
    let content = fs::read_to_string(meta_path).ok()?;
    let mut meta: CrateMeta = toml::from_str(&content).ok()?;

    if meta.schema_version == 0 {
        meta.schema_version = META_SCHEMA_VERSION;
        let rewritten = toml::to_string_pretty(&meta).ok()?;
        fs::write(meta_path, rewritten).ok()?;
    }

    if meta.schema_version > META_SCHEMA_VERSION {
        return None;
    }

    Some(meta)
}

fn save_meta(meta_path: &Path, meta: &CrateMeta) -> Result<()> {
    let meta_content = toml::to_string_pretty(meta)
        .map_err(|e| AiDocsError::Other(format!("Failed to serialize meta: {e}")))?;
    fs::write(meta_path, meta_content)?;
    Ok(())
}

pub fn is_cached(
    output_dir: &Path,
    crate_name: &str,
    version: &str,
    crate_config: &CrateDoc,
) -> bool {
    let crate_dir = output_dir.join(format!("{crate_name}@{version}"));
    let meta_path = crate_dir.join(".aifd-meta.toml");

    if !meta_path.exists() {
        return false;
    }

    match load_meta_with_migration(&meta_path) {
        Some(meta) => {
            let expected_fp = crate_config_fingerprint(crate_config);
            meta.version == version
                && meta
                    .config_fingerprint
                    .as_ref()
                    .map(|fp| fp == &expected_fp)
                    .unwrap_or(false)
        }
        None => false,
    }
}

pub struct SaveRequest<'a> {
    pub crate_name: &'a str,
    pub version: &'a str,
    pub fetched_files: &'a [FetchedFile],
    pub crate_config: &'a CrateDoc,
}

pub fn save_crate_files(
    output_dir: &Path,
    save_ctx: &SaveContext<'_>,
    req: SaveRequest<'_>,
) -> Result<SavedCrate> {
    let crate_dir = output_dir.join(format!("{}@{}", req.crate_name, req.version));

    if crate_dir.exists() {
        fs::remove_dir_all(&crate_dir)?;
    }
    fs::create_dir_all(&crate_dir)?;

    let mut saved_names = Vec::new();

    for file in req.fetched_files {
        let flat_name = flatten_filename(&file.path);
        let mut content = file.content.clone();

        if file.path.to_lowercase().contains("changelog") {
            content = changelog::truncate_changelog(&content, req.version);
        }

        content = truncate_if_needed(&content, save_ctx.max_file_size_kb);

        if should_inject_header(&file.path) {
            content = inject_header(
                &content,
                save_ctx.repo,
                &save_ctx.resolved.git_ref,
                &file.path,
                save_ctx.resolved.is_fallback,
                req.version,
                &file.source_url,
            );
        }

        let file_path = crate_dir.join(&flat_name);
        fs::write(&file_path, &content)?;
        debug!("Saved: {:?}", file_path);
        saved_names.push(flat_name);
    }

    let meta = CrateMeta {
        schema_version: META_SCHEMA_VERSION,
        version: req.version.to_string(),
        git_ref: save_ctx.resolved.git_ref.clone(),
        fetched_at: Utc::now().format("%Y-%m-%d").to_string(),
        is_fallback: save_ctx.resolved.is_fallback,
        config_fingerprint: Some(crate_config_fingerprint(req.crate_config)),
    };

    save_meta(&crate_dir.join(".aifd-meta.toml"), &meta)?;

    info!(
        "  ðŸ’¾ {}@{}: {} files saved to {:?}",
        req.crate_name,
        req.version,
        saved_names.len(),
        crate_dir
    );

    let saved = SavedCrate {
        name: req.crate_name.to_string(),
        version: req.version.to_string(),
        git_ref: save_ctx.resolved.git_ref.clone(),
        is_fallback: save_ctx.resolved.is_fallback,
        files: saved_names,
        ai_notes: req.crate_config.ai_notes.clone(),
    };

    fs::write(crate_dir.join("_SUMMARY.md"), render_crate_summary(&saved))?;

    Ok(saved)
}

pub struct SaveContext<'a> {
    pub repo: &'a str,
    pub resolved: &'a ResolvedRef,
    pub max_file_size_kb: usize,
}

pub fn read_cached_info(
    output_dir: &Path,
    crate_name: &str,
    version: &str,
    crate_config: &CrateDoc,
) -> Option<SavedCrate> {
    let crate_dir = output_dir.join(format!("{crate_name}@{version}"));
    let meta_path = crate_dir.join(".aifd-meta.toml");
    let meta = load_meta_with_migration(&meta_path)?;

    let mut files: Vec<String> = fs::read_dir(&crate_dir)
        .ok()?
        .filter_map(|e| e.ok())
        .filter_map(|e| {
            let name = e.file_name().to_str()?.to_string();
            if name.starts_with('.') || name == "_SUMMARY.md" {
                None
            } else {
                Some(name)
            }
        })
        .collect();
    files.sort();

    Some(SavedCrate {
        name: crate_name.to_string(),
        version: version.to_string(),
        git_ref: meta.git_ref,
        is_fallback: meta.is_fallback,
        files,
        ai_notes: crate_config.ai_notes.clone(),
    })
}

pub fn prune(
    output_dir: &Path,
    config: &Config,
    lock_versions: &HashMap<String, String>,
) -> Result<()> {
    if !output_dir.exists() {
        return Ok(());
    }

    let configured: HashSet<&str> = config.crates.keys().map(String::as_str).collect();

    for entry in fs::read_dir(output_dir)? {
        let entry = entry?;
        let path = entry.path();

        if !path.is_dir() {
            continue;
        }

        let Some(dir_name) = path.file_name().and_then(|n| n.to_str()) else {
            continue;
        };

        let Some((crate_name, dir_version)) = split_name_version(dir_name) else {
            continue;
        };

        let should_remove = if !configured.contains(crate_name) {
            true
        } else {
            match lock_versions.get(crate_name) {
                Some(lock_ver) => lock_ver != dir_version,
                None => true,
            }
        };

        if should_remove {
            info!("  ðŸ—‘ Pruning {dir_name}");
            fs::remove_dir_all(path)?;
        }
    }

    Ok(())
}

fn split_name_version(dir_name: &str) -> Option<(&str, &str)> {
    let (name, version) = dir_name.rsplit_once('@')?;
    if name.is_empty() || version.is_empty() {
        return None;
    }
    Some((name, version))
}

pub fn rust_output_dir(base_output_dir: &Path) -> PathBuf {
    if base_output_dir.file_name().and_then(|n| n.to_str()) == Some("rust") {
        return base_output_dir.to_path_buf();
    }
    base_output_dir.join("rust")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::CrateDoc;

    #[test]
    fn test_flatten_root_file() {
        assert_eq!(flatten_filename("README.md"), "README.md");
    }

    #[test]
    fn test_flatten_nested_file() {
        assert_eq!(
            flatten_filename("docs/guides/overview.md"),
            "docs__guides__overview.md"
        );
    }

    #[test]
    fn test_should_inject_header() {
        assert!(should_inject_header("README.md"));
        assert!(should_inject_header("guide.html"));
        assert!(!should_inject_header("example.rs"));
    }

    #[test]
    fn test_truncate_large_file() {
        let content = "x".repeat(300 * 1024);
        let result = truncate_if_needed(&content, 200);
        assert!(result.contains("[TRUNCATED by ai-fdocs at 200KB]"));
    }

    #[test]
    fn test_split_name_version() {
        assert_eq!(split_name_version("serde@1.0.0"), Some(("serde", "1.0.0")));
        assert_eq!(split_name_version("serde"), None);
    }

    #[test]
    fn test_config_fingerprint_changes_when_repo_changes() {
        let mut cfg = CrateDoc {
            repo: Some("serde-rs/serde".to_string()),
            subpath: None,
            files: None,
            sources: None,
            ai_notes: String::new(),
        };

        let fp1 = crate_config_fingerprint(&cfg);
        cfg.repo = Some("tokio-rs/tokio".to_string());
        let fp2 = crate_config_fingerprint(&cfg);

        assert_ne!(fp1, fp2);
    }

    #[test]
    fn test_render_summary_contains_file_links() {
        let saved = SavedCrate {
            name: "serde".to_string(),
            version: "1.0.0".to_string(),
            git_ref: "v1.0.0".to_string(),
            is_fallback: false,
            files: vec!["README.md".to_string(), "CHANGELOG.md".to_string()],
            ai_notes: "Use derive macros".to_string(),
        };

        let summary = render_crate_summary(&saved);
        assert!(summary.contains("# serde@1.0.0"));
        assert!(summary.contains("## AI Notes"));
        assert!(summary.contains("[README.md](README.md)"));
    }
    #[test]
    fn test_load_meta_migrates_legacy_schema() {
        let tmp =
            std::env::temp_dir().join(format!("ai-fdocs-meta-migrate-{}", std::process::id()));
        let _ = fs::remove_dir_all(&tmp);
        fs::create_dir_all(&tmp).expect("create temp dir");
        let meta_path = tmp.join(".aifd-meta.toml");

        let legacy = r#"version = "1.0.0"
git_ref = "v1.0.0"
fetched_at = "2026-01-01"
is_fallback = false
config_fingerprint = "abc"
"#;
        fs::write(&meta_path, legacy).expect("write legacy meta");

        let migrated = load_meta_with_migration(&meta_path).expect("load migrated");
        assert_eq!(migrated.schema_version, META_SCHEMA_VERSION);

        let rewritten = fs::read_to_string(&meta_path).expect("read rewritten meta");
        assert!(rewritten.contains("schema_version = 1"));

        let _ = fs::remove_dir_all(&tmp);
    }

    #[test]
    fn test_load_meta_rejects_newer_schema() {
        let tmp = std::env::temp_dir().join(format!("ai-fdocs-meta-newer-{}", std::process::id()));
        let _ = fs::remove_dir_all(&tmp);
        fs::create_dir_all(&tmp).expect("create temp dir");
        let meta_path = tmp.join(".aifd-meta.toml");

        let newer = r#"schema_version = 99
version = "1.0.0"
git_ref = "v1.0.0"
fetched_at = "2026-01-01"
is_fallback = false
config_fingerprint = "abc"
"#;
        fs::write(&meta_path, newer).expect("write newer meta");

        assert!(load_meta_with_migration(&meta_path).is_none());

        let _ = fs::remove_dir_all(&tmp);
    }
}
